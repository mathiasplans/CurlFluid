<!DOCTYPE>
<html>
  <head>
    <title>Computer Graphics - Basic II - Task 4.1 - Procedural Generation</title>
    <meta charset="UTF-8">
    <script type="text/javascript" src="WebGL.js"></script>
    <script type="text/javascript" src="three.r108.js"></script>
    <script type="text/javascript">
      var size = 800;

      var printScene;
      var printCamera;
      var printMaterial;

      var curlScene;
      var curlCamera;
      var curlMaterial;

      var renderer;

      var printVertexShader, printFragmentShader;
      var curlVertexShader, curlFragmentShader;

      var quadMaterial;
      var particleMaterial;

      // Render targets
      var bufferTarget = [
        new THREE.WebGLRenderTarget(size, size),
        new THREE.WebGLRenderTarget(size, size)
      ];

      function onLoad() {
        if (WEBGL.isWebGL2Available() === false ) {
          document.body.appendChild(WEBGL.getWebGL2ErrorMessage());
          console.log("WebGL2 is not available");
        }

        var canvasContainer = document.getElementById('myCanvasContainer');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('webgl2');
        canvasContainer.appendChild(canvas);

        printVertexShader = document.getElementById('printVert').textContent;
        printFragmentShader = document.getElementById('printFrag').textContent;

        curlVertexShader = document.getElementById('curlVert').textContent;
        curlFragmentShader = document.getElementById('curlFrag').textContent;

        // Renderer
        renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          context: context
        });

        renderer.setSize(size, size);

        // Scenes
        var bScene = createBufferScene();
        curlScene = bScene[0];
        curlCamera = bScene[1];
        curlMaterial = bScene[2];

        var pScene = createFinalScene();
        printScene = pScene[0];
        printCamera = pScene[1];
        printMaterial = pScene[2];

        draw();
      }

      function createBufferScene() {
        // Particle position calculation
        var bufMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: {
              value: 0
            },

            size: {
              value: size
            },

            previousFrame: {
              value: bufferTarget[1].texture
            }
          },

          vertexShader: curlVertexShader,
          fragmentShader: curlFragmentShader
        });

        var bufGeometry = new THREE.PlaneBufferGeometry(size, size);

        var buffer = new THREE.Mesh(bufGeometry, bufMaterial);

        // Camera
        var cam = new THREE.OrthographicCamera(-size / 2, size / 2, size / 2, -size / 2, 0.1, 10);
        cam.position.set(0, 0, 4);
        cam.lookAt(buffer.position);
        cam.up.set(0, 1, 0);

        var s = new THREE.Scene();
        s.add(buffer);
        s.add(cam);

        return [s, cam, bufMaterial];
      }

      function createFinalScene() {
        // Particle position calculation
        var finalMaterial = new THREE.ShaderMaterial({
          uniforms: {
            size: {
              value: size
            },

            target: {
              value: bufferTarget[0].texture
            }
          },
          vertexShader: printVertexShader,
          fragmentShader: printFragmentShader
        });

        var finalGeometry = new THREE.PlaneBufferGeometry(size, size);

        var final = new THREE.Mesh(finalGeometry, finalMaterial);

        // Camera
        var cam = new THREE.OrthographicCamera(-size / 2, size / 2, size / 2, -size / 2, 0.1, 10);
        cam.position.set(0, 0, 4);
        cam.lookAt(final.position);
        cam.up.set(0, 1, 0);

        var s = new THREE.Scene();
        s.add(final);
        s.add(cam);

        return [s, cam, finalMaterial];
      }

      var parity = 0;
      var x = 0;

      function draw() {
        requestAnimationFrame(draw);

        //if (x == 100) {
        // Get the parity
        parity = ++parity & 1;

        /* Position map */
        // Swap between the two textures.
        curlMaterial.uniforms.time.value += 0.005;
        curlMaterial.uniforms.previousFrame.value = bufferTarget[1 - parity].texture;

        // Render the position map
        renderer.setRenderTarget(bufferTarget[parity]);
        renderer.render(curlScene, curlCamera);

        /* Particles */
        // Now that we have the position map, we can move the particles according to it
        printMaterial.uniforms.target.value = bufferTarget[parity].texture;

        // Render
        renderer.setRenderTarget(null);
        renderer.render(printScene, printCamera);
        // }
        //
        // ++x;
        // x %= 200;
      }
    </script>

    <script id="printVert" type="x-shader/x-vertex">
      out vec3 interpolatedPosition;
      out vec3 interpolatedNormal;

      void main() {
        interpolatedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="printFrag" type="x-shader/x-fragment">
      uniform sampler2D target;
      in vec3 interpolatedPosition;

      void main() {
        // TODO: Read the color of the particle from a texture
        vec3 realPosition = (interpolatedPosition / 400.0 + 1.0) / 2.0;

        gl_FragColor = vec4(texture(target, realPosition.xy).xyz, 1.0);
      }
    </script>

    <script id="curlVert" type="x-shader/x-vertex">
      out vec3 interpolatedPosition;
      out vec3 interpolatedNormal;
      out vec3 interpolatedLocalPosition;

      void main() {
        interpolatedLocalPosition = position;
        interpolatedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="curlFrag" type="x-shader/x-fragment">
      uniform sampler2D previousFrame;
      uniform float time;
      uniform float size;

      in vec3 interpolatedLocalPosition;
      in vec3 interpolatedPosition;
      in vec3 interpolatedNormal;

      float F = 1.0 / 3.0;
      float G = 1.0 / 6.0;

      vec3 hash(ivec3 internal, ivec3 s) {
        vec3 p = vec3(internal) + vec3(s);
        p = vec3(
          dot(p, vec3(127.1,311.7, 74.7)),
          dot(p, vec3(269.5,163.3,226.1)),
          dot(p, vec3(114.5,271.9,124.6))
        );

        return normalize(-1.0 + 2.0 * fract(sin(p) * 43758.5453123));
      }

      float noise(in vec3 p) {
        float sum = p.x + p.y + p.z;
        float skewFactor = sum * F;

        // Skew
        ivec3 internal = ivec3(floor(p + skewFactor));

        int unsum = internal.x + internal.y + internal.z;
        float unskewFactor = float(unsum) * G;

        // Unskew
        vec3 unskew = vec3(internal) - unskewFactor;

        // Distance
        vec3 dst = p - unskew;

        // Determine in which simplices we are in
        ivec3 s[4];
        s[0] = ivec3(0);
        s[3] = ivec3(1);

        if (dst.x >= dst.y) {
          if (dst.y >= dst.z) {
            s[1] = ivec3(1, 0, 0);
            s[2] = ivec3(1, 1, 0);
          }

          else if (dst.x >= dst.z) {
            s[1] = ivec3(1, 0, 0);
            s[2] = ivec3(1, 0, 1);
          }

          else {
            s[1] = ivec3(0, 0, 1);
            s[2] = ivec3(1, 0, 1);
          }
        }

        // dst.x < dst.y
        else {
          if (dst.y < dst.z) {
            s[1] = ivec3(0, 0, 1);
            s[2] = ivec3(0, 1, 1);
          }

          else if (dst.x < dst.z) {
            s[1] = ivec3(0, 1, 0);
            s[2] = ivec3(0, 1, 1);
          }

          else {
            s[1] = ivec3(0, 1, 0);
            s[2] = ivec3(1, 1, 0);
          }
        }

        // Offsets for conrners
        vec3 offset[] = vec3[](
          dst,
          dst - vec3(s[1]) + G,
          dst - vec3(s[2]) + 2.0 * G,
          dst - vec3(s[3]) + 3.0 * G
        );

        // Gradients
        vec3 g[4];
        for (int i = 0; i < 4; ++i) {
          g[i] = hash(internal, s[i]);
        }

        // Interpolate
        vec3 tmp;
        float t = 0.0;
        float n[] = float[](0.0, 0.0, 0.0, 0.0);

        for (int i = 0; i < 4; ++i) {
          tmp = pow(offset[i], vec3(2.0));
          t = 0.5 - tmp.x - tmp.y - tmp.z;

          if (t > 0.0) {
            t *= t;
            n[i] = t * t * dot(g[i], offset[i]);
          }
        }

        const float normalization = 37.837227241611314102871574478976;
        //const float normalization = 32.0;

        // ~[-1.0, 1.0]
        return (normalization * (n[0] + n[1] + n[2] + n[3]));
      }

      float noise(in vec2 p) {
        return noise(vec3(p, 0.0));
      }

      /**
       * Calculates derivative of the noise (on 2D slice)
       */
      vec2 dnoise2(in vec3 p) {
        // Coordinates
        vec2 coord = p.xy;

        // Delta
        // float delta = 1.0 / 100000.0;

        float o = noise(coord);

        // Dn/Dx
        float x1 = o;
        float x2 = noise(coord + dFdx(coord));
        float dx = (x2 - x1) / dFdx(coord).x;

        // Dn/Dy
        float y1 = o;
        float y2 = noise(coord + dFdy(coord));
        float dy = (y2 - y1) / dFdy(coord).y;

        // // Dn/Dx
        // float dx = dFdx(noise(coord)) / dFdx(coord).x;
        //
        // // Dn/Dy
        // float dy = dFdy(noise(coord)) / dFdy(coord).y;

        return vec2(dx, dy) / 6.0;
      }

      vec3 dnoise3(in vec3 p) {
        // Coordinates
        vec3 coord = p;

        // Delta
        float delta = 1.0 / 10000.0;

        // Dn/Dx
        float x1 = noise(coord - vec3(delta, 0.0, 0.0));
        float x2 = noise(coord + vec3(delta, 0.0, 0.0));
        float dx = (x2 - x1) / delta;

        // Dn/Dy
        float y1 = noise(coord - vec3(0.0, delta, 0.0));
        float y2 = noise(coord + vec3(0.0, delta, 0.0));
        float dy = (y2 - y1) / delta;

        // Dn/Dz
        float z1 = noise(coord - vec3(0.0, 0.0, delta));
        float z2 = noise(coord + vec3(0.0, 0.0, delta));
        float dz = (z2 - z1) / delta;

        return vec3(dx, dy, dz);
      }

      vec2 cnoise2(in vec3 p) {
        vec2 d = dnoise2(p);
        return vec2(d.y, -d.x) / 20.0;
      }

      vec3 cnoise3(in vec3 p) {
        vec3 d = dnoise3(p);
        return vec3(d.z - d.y, d.x - d.z, d.y - d.x);
      }

      void main() {
        // Get the current position in the position map
        //vec3 current = texture(previousFrame, interpolatedLocalPosition.xy / vec2(size)).xyz;

        // Add the curl to it
        //current += vec3(cnoise2(interpolatedLocalPosition + current), 0.0);

        vec3 realPosition = (interpolatedPosition / 400.0 + 1.0) / 2.0;
        realPosition.z = 0.0;
        vec2 shift = cnoise2(5.0 * realPosition + vec3(0.0, time, 0.0));
        vec2 uvPosition = realPosition.xy + shift;

        vec3 color = texture(previousFrame, uvPosition).xyz;

        if (color == vec3(0.0, 0.0, 0.0))
          color = vec3(pow(abs(cos(0.035 * interpolatedPosition.x)), 5.0), pow(abs(cos(0.035 * interpolatedPosition.x)), 2.6), pow(abs(cos(0.035 * interpolatedPosition.y)), 3.0));

        // Just makes the swirls last longer (introduces different pixels into mix)
        if (realPosition.y < 0.1)
          color *= 1.0 + (0.1 - realPosition.y) / 800.0;

        //gl_FragColor = vec4(current, 1.0);
        gl_FragColor = vec4(color, 1.0);
        // gl_FragColor = vec4(uvPosition, 0.0, 1.0);
      }
    </script>

  </head>
  <body onload="onLoad()">
    <div id="myCanvasContainer"></div>
    <canvas id="canvas"></canvas>
  </body>
</html>
