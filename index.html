<!DOCTYPE>
<html>
  <head>
    <title>Computer Graphics - Basic II - Task 4.1 - Procedural Generation</title>
    <meta charset="UTF-8">
    <script type="text/javascript" src="WebGL.js"></script>
    <script type="text/javascript" src="three.r108.js"></script>
    <script type="text/javascript">
      var size = 800;

      var camera;
      var particleScene;
      var curlScene;
      var particleRenderer;
      var curlRenderer;
      var planet;
      var lightPosition;

      var particleVertexShader, particleFragmentShader;
      var curlVertexShader, curlFragmentShader;

      var quadMaterial;
      var particleMaterial;

      // Render targets
      var target = [
        new THREE.WebGLRenderTarget(size, size),
        new THREE.WebGLRenderTarget(size, size)
      ];

      /**
       * Function to tell us the milliseconds
       */
      function millis() {
        return (new Date()).getTime();
      }

      /**
       * Converts degrees to radians
       */
      function toRad(degree) {
        return Math.PI * 2 * degree / 360;
      }

      function onLoad() {
        if (WEBGL.isWebGL2Available() === false ) {
          document.body.appendChild( WEBGL.getWebGL2ErrorMessage() );
          console.log("WebGL2 is not available");
        }

        var canvasContainer = document.getElementById('myCanvasContainer');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('webgl2', {alpha: false});
        canvasContainer.appendChild(canvas);

        particleVertexShader = document.getElementById('particleVert').textContent;
        particleFragmentShader = document.getElementById('particleFrag').textContent;

        curlVertexShader = document.getElementById('curlVert').textContent;
        curlFragmentShader = document.getElementById('curlFrag').textContent;

        // Renderer for particles
        particleRenderer = new THREE.WebGLRenderer({
          canvas: canvas,
          context: context,
          preserveDrawingBuffer: true
        });

        particleRenderer.autoClear = false;
        particleRenderer.setSize(size, size);

        // Renderer for position textures
        curlRenderer = new THREE.WebGLRenderer({
          context: context
        });

        curlRenderer.setSize(size, size);

        particleMaterial = new THREE.ShaderMaterial({
          uniforms: {
            positionMap: {
              value: target[1].texture
            },

            size: {
              value: size
            }
          },
          vertexShader: particleVertexShader,
          fragmentShader: particleFragmentShader
        });

        var particleGeometry = new THREE.BufferGeometry();

        // Let the particles be squares which fit into one pixel
        var pc = 1 / size;
        var vertices = new Float32Array([
          -pc, -pc,  pc,
           pc, -pc,  pc,
           pc,  pc,  pc,

           pc,  pc,  pc,
          -pc,  pc,  pc,
          -pc, -pc,  pc
        ]);

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

        // Array of particles
        var particles = [];

        // Create lots of particles
        for (var i = 0; i < size; ++i) {
          for (var j = 0; j < size; ++j) {
            var particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.positon.set(i - size / 2, j - size / 2, 0);

            // TODO: Set the color

            particles.push(particle);
          }
        }

        // Particle position calculation
        quadMaterial = new THREE.ShaderMaterial({
          uniforms: {
            previousFrame: {
              value: target[0].texture
            },

            time: {
              value: 0
            },
          },
          vertexShader: curlVertexShader,
          fragmentShader: curlFragmentShader
        });

        var quadGeometry = new THREE.PlaneBufferGeometry(size, size);

        var uvCoord = new Float32Array([
          0,    size,
          size, size,
          0,    0,
          size, 0
        ]);

        quadGeometry.addAttribute("uvCoord", new THREE.BufferAttribute(uvCoord, 2));

        var quad = new THREE.Mesh(quadGeometry, quadMaterial);

        // Camera
        camera = new THREE.OrthographicCamera(-size / 2, size / 2, size / 2, -size / 2, 0.1, 10);
        camera.position.set(0, 0, 4);
        camera.lookAt(quad.position);
        camera.up.set(0, 1, 0);

        // Scenes
        curlScene = new THREE.Scene();
        curlScene.add(quad);

        particleScene = new THREE.Scene();
        particleScene.add(camera);
        for (var p in particles) {
          particleScene.add(p);
        }

        draw();
      }

      var parity = 0;

      function draw() {
        requestAnimationFrame(draw);

        // Get the parity
        parity = ++parity & 1;

        /* Position map */
        // Swap between the two textures.
        curlRenderer.setRenderTarget(target[parity]);
        curlMaterial.uniforms.previousFrame.value = target[1 - parity].texture;
        curlMaterial.uniforms.time.value = 0;

        // Render the position map
        curlRenderer.render(curlScene, camera);

        /* Particles */
        // Now that we have the position map, we can move the particles according to it
        particleMaterial.uniforms.positionMap.value = target[parity];

        // Render the particles onto the screen
        particleRenderer.render(particleScene, camera);
      }
    </script>

    <script id="particleVert" type="x-shader/x-vertex">
      uniform float size;
      uniform sampler2D positionMap;

      out vec3 interpolatedPosition; //We interpolate the position
      out vec3 interpolatedNormal;   //We interpolate the normal
      out vec3 interpolatedLocalPosition;

      void main() {
        // Add the offset to the position
        vec2 uvCoord = vec2(position.x / size + 0.5, position.y / size + 0.5);
        position += texture(positionMap, uvCoord);

        interpolatedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
        interpolatedNormal = normalize(normalMatrix * normal).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="particleFrag" type="x-shader/x-fragment">
      in vec3 interpolatedLocalPosition;
      in vec3 interpolatedPosition;


      void main() {
        // TODO: Read the color of the particle from a texture

        gl_Color = vec4(1.0);
      }
    </script>

    <script id="curlVert" type="x-shader/x-vertex">
      out vec3 interpolatedPosition;
      out vec3 interpolatedNormal;
      out vec3 interpolatedLocalPosition;
      out vec2 interpolatedUV;

      void main() {
        interpolatedLocalPosition = position;
        interpolatedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz; //Replace these 2 lines
        interpolatedNormal = normalize(normalMatrix * normal).xyz;

        interpolatedUV = uvCoord;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="curlFrag" type="x-shader/x-fragment">
      uniform sampler2D previousFrame;

      in vec3 interpolatedLocalPosition;
      in vec3 interpolatedPosition;
      in vec3 interpolatedNormal;

      float F = 1.0 / 3.0;
      float G = 1.0 / 6.0;

      vec3 hash(ivec3 internal, ivec3 s) {
        vec3 p = vec3(internal) + vec3(s);
        p = vec3(
          dot(p, vec3(127.1,311.7, 74.7)),
          dot(p, vec3(269.5,163.3,226.1)),
          dot(p, vec3(114.5,271.9,124.6))
        );

        return normalize(-1.0 + 2.0 * fract(sin(p) * 43758.5453123));
      }

      float noise(in vec3 p) {
        float sum = p.x + p.y + p.z;
        float skewFactor = sum * F;

        // Skew
        ivec3 internal = ivec3(floor(p + skewFactor));

        int unsum = internal.x + internal.y + internal.z;
        float unskewFactor = float(unsum) * G;

        // Unskew
        vec3 unskew = vec3(internal) - unskewFactor;

        // Distance
        vec3 dst = p - unskew;

        // Determine in which simplices we are in
        ivec3 s[4];
        s[0] = ivec3(0);
        s[3] = ivec3(1);

        if (dst.x >= dst.y) {
          if (dst.y >= dst.z) {
            s[1] = ivec3(1, 0, 0);
            s[2] = ivec3(1, 1, 0);
          }

          else if (dst.x >= dst.z) {
            s[1] = ivec3(1, 0, 0);
            s[2] = ivec3(1, 0, 1);
          }

          else {
            s[1] = ivec3(0, 0, 1);
            s[2] = ivec3(1, 0, 1);
          }
        }

        // dst.x < dst.y
        else {
          if (dst.y < dst.z) {
            s[1] = ivec3(0, 0, 1);
            s[2] = ivec3(0, 1, 1);
          }

          else if (dst.x < dst.z) {
            s[1] = ivec3(0, 1, 0);
            s[2] = ivec3(0, 1, 1);
          }

          else {
            s[1] = ivec3(0, 1, 0);
            s[2] = ivec3(1, 1, 0);
          }
        }

        // Offsets for conrners
        vec3 offset[] = vec3[](
          dst,
          dst - vec3(s[1]) + G,
          dst - vec3(s[2]) + 2.0 * G,
          dst - vec3(s[3]) + 3.0 * G
        );

        // Gradients
        vec3 g[4];
        for (int i = 0; i < 4; ++i) {
          g[i] = hash(internal, s[i]);
        }

        // Interpolate
        vec3 tmp;
        float t = 0.0;
        float n[] = float[](0.0, 0.0, 0.0, 0.0);

        for (int i = 0; i < 4; ++i) {
          tmp = pow(offset[i], vec3(2.0));
          t = 0.5 - tmp.x - tmp.y - tmp.z;

          if (t > 0.0) {
            t *= t;
            n[i] = t * t * dot(g[i], offset[i]);
          }
        }

        const float normalization = 37.837227241611314102871574478976;

        // ~[-1.0, 1.0]
        return (normalization * (n[0] + n[1] + n[2] + n[3]));
      }

      vec3 curlNoise(in vec3 p) {
        // Get the noise on p coords
        float origin = noise(p);

        // Get the noise on p + dx coords
        float d = 1.0 / 1000.0;
        float xDeriv = origin - noise(p + vec3(d, 0.0, 0.0));

        // Get the noide on p + dy coords
        float yDeriv = origin - noise(p + vec3(0.0, d, 0.0));

        return vec3(yDeriv / d, -xDerive / d, 0.0);
      }

      void main() {
        // Get the current position in the position map
        vec3 current = texture(previousFrame, interpolatedUV);

        // Add the curl to it
        current += curlNoise(interpolatedLocalPosition + current);

        gl_FragColor = vec4(current, 1.0);
      }
    </script>

  </head>
  <body onload="onLoad()">
    <div id="myCanvasContainer"></div>
    <canvas id="canvas"></canvas>
  </body>
</html>
