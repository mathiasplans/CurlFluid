<!DOCTYPE>
<html>
  <head>
    <title>Computer Graphics - Basic II - Task 4.1 - Procedural Generation</title>
    <meta charset="UTF-8">
    <script type="text/javascript" src="WebGL.js"></script>
    <script type="text/javascript" src="three.r108.js"></script>
    <script type="text/javascript">
      var size = 800;

      var curlCamera;
      var particleCamera;
      var particleScene;
      var curlScene;
      var particleRenderer;
      var curlRenderer;
      var planet;
      var lightPosition;

      var particleVertexShader, particleFragmentShader;
      var curlVertexShader, curlFragmentShader;

      var quadMaterial;
      var particleMaterial;

      // Render targets
      var target = [
        new THREE.WebGLRenderTarget(size, size),
        new THREE.WebGLRenderTarget(size, size)
      ];

      /**
       * Function to tell us the milliseconds
       */
      function millis() {
        return (new Date()).getTime();
      }

      /**
       * Converts degrees to radians
       */
      function toRad(degree) {
        return Math.PI * 2 * degree / 360;
      }

      function onLoad() {
        if (WEBGL.isWebGL2Available() === false ) {
          document.body.appendChild( WEBGL.getWebGL2ErrorMessage() );
          console.log("WebGL2 is not available");
        }

        var canvasContainer = document.getElementById('myCanvasContainer');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('webgl2', {alpha: false});
        canvasContainer.appendChild(canvas);

        particleVertexShader = document.getElementById('particleVert').textContent;
        particleFragmentShader = document.getElementById('particleFrag').textContent;

        curlVertexShader = document.getElementById('curlVert').textContent;
        curlFragmentShader = document.getElementById('curlFrag').textContent;

        // Renderer for particles
        particleRenderer = new THREE.WebGLRenderer({
          canvas: canvas,
          context: context//,
          //preserveDrawingBuffer: true
        });

        //particleRenderer.autoClear = false;
        particleRenderer.setSize(size, size);

        // Renderer for position textures
        curlRenderer = new THREE.WebGLRenderer({
          canvas: canvas,
          context: context
        });

        curlRenderer.setSize(size, size);

        particleMaterial = new THREE.ShaderMaterial({
          uniforms: {
            positionMap: {
              value: target[1].texture
            },

            size: {
              value: size
            }
          },
          vertexShader: particleVertexShader,
          fragmentShader: particleFragmentShader
        });

        var pc = 1 / size;
        var particleGeometry = new THREE.PlaneBufferGeometry(pc, pc);

        // Array of particles
        var particles = [];

        // Create lots of particles
        for (var i = 0; i < size / 4; ++i) {
          for (var j = 0; j < size / 4; ++j) {
            var particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.position.set(i - 4 * size / 2, j - 4 * size / 2, 0);

            // TODO: Set the color

            particles.push(particle);
          }
        }
        //var particle = new THREE.Mesh(particleGeometry, particleMaterial);
        //particle.position.set(0, 0, 0);

        //// TODO: Set the color

        //particles.push(particle);

        // Particle position calculation
        quadMaterial = new THREE.ShaderMaterial({
          uniforms: {
            previousFrame: {
              value: target[0].texture
            },

            time: {
              value: 0
            },

            size: {
              value: size
            }
          },
          vertexShader: curlVertexShader,
          fragmentShader: curlFragmentShader
        });

        var quadGeometry = new THREE.PlaneBufferGeometry(size, size);
        console.log(quadGeometry);

//        var uvCoord = new Float32Array([
//          0,    size,
//          size, size,
//          0,    0,
//          size, 0
//        ]);

//        quadGeometry.addAttribute("uvCoord", new THREE.BufferAttribute(uvCoord, 2));

        var quad = new THREE.Mesh(quadGeometry, quadMaterial);

        // Camera
        curlCamera = new THREE.OrthographicCamera(-size / 2, size / 2, size / 2, -size / 2, 0.1, 10);
        curlCamera.position.set(0, 0, 4);
        curlCamera.lookAt(quad.position);
        curlCamera.up.set(0, 1, 0);

        particleCamera = new THREE.OrthographicCamera(-size / 2, size / 2, size / 2, -size / 2, 0.1, 10);
        particleCamera.position.set(0, 0, 4);
        particleCamera.lookAt(quad.position);
        particleCamera.up.set(0, 1, 0);

        // Scenes
        curlScene = new THREE.Scene();
        curlScene.add(quad);
        curlScene.add(curlCamera);

        particleScene = new THREE.Scene();
        particleScene.add(particleCamera);
        for (var p of particles) {
          particleScene.add(p);
        }

        draw();
      }

      var parity = 0;

      function draw() {
        requestAnimationFrame(draw);

        // Get the parity
        parity = ++parity & 1;

        /* Position map */
        // Swap between the two textures.
        //curlRenderer.setRenderTarget(target[parity]);
        quadMaterial.uniforms.previousFrame.value = target[1 - parity].texture;
        quadMaterial.uniforms.time.value = 0;
        curlRenderer.setRenderTarget(null);

        // Render the position map
        curlRenderer.render(curlScene, curlCamera);

        /* Particles */
        // Now that we have the position map, we can move the particles according to it
        particleMaterial.uniforms.positionMap.value = target[parity].texture;

        // Render the particles onto the screen
        //particleRenderer.render(particleScene, particleCamera);
      }
    </script>

    <script id="particleVert" type="x-shader/x-vertex">
      uniform float size;
      uniform sampler2D positionMap;

      out vec3 interpolatedPosition; //We interpolate the position
      out vec3 interpolatedNormal;   //We interpolate the normal
      out vec3 interpolatedLocalPosition;

      void main() {
        // Add the offset to the position
        vec2 uvCoord = vec2(position.x / size, position.y / size);
        vec3 translated = texture(positionMap, uvCoord).xyz;

        interpolatedPosition = (modelViewMatrix * vec4(translated, 1.0)).xyz;
        interpolatedNormal = normalize(normalMatrix * normal).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(translated, 1.0);
      }
    </script>

    <script id="particleFrag" type="x-shader/x-fragment">
      in vec3 interpolatedLocalPosition;
      in vec3 interpolatedPosition;


      void main() {
        // TODO: Read the color of the particle from a texture

        gl_FragColor = vec4(interpolatedLocalPosition, 1.0);
      }
    </script>

    <script id="curlVert" type="x-shader/x-vertex">
      out vec3 interpolatedPosition;
      out vec3 interpolatedNormal;
      out vec3 interpolatedLocalPosition;

      void main() {
        interpolatedLocalPosition = position;
        interpolatedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
        interpolatedNormal = normalize(normalMatrix * normal).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="curlFrag" type="x-shader/x-fragment">
      uniform sampler2D previousFrame;
      uniform float size;

      in vec3 interpolatedLocalPosition;
      in vec3 interpolatedPosition;
      in vec3 interpolatedNormal;

      float F = 1.0 / 3.0;
      float G = 1.0 / 6.0;

      vec3 hash(ivec3 internal, ivec3 s) {
        vec3 p = vec3(internal) + vec3(s);
        p = vec3(
          dot(p, vec3(127.1,311.7, 74.7)),
          dot(p, vec3(269.5,163.3,226.1)),
          dot(p, vec3(114.5,271.9,124.6))
        );

        return normalize(-1.0 + 2.0 * fract(sin(p) * 43758.5453123));
      }

      float noise(in vec3 p) {
        float sum = p.x + p.y + p.z;
        float skewFactor = sum * F;

        // Skew
        ivec3 internal = ivec3(floor(p + skewFactor));

        int unsum = internal.x + internal.y + internal.z;
        float unskewFactor = float(unsum) * G;

        // Unskew
        vec3 unskew = vec3(internal) - unskewFactor;

        // Distance
        vec3 dst = p - unskew;

        // Determine in which simplices we are in
        ivec3 s[4];
        s[0] = ivec3(0);
        s[3] = ivec3(1);

        if (dst.x >= dst.y) {
          if (dst.y >= dst.z) {
            s[1] = ivec3(1, 0, 0);
            s[2] = ivec3(1, 1, 0);
          }

          else if (dst.x >= dst.z) {
            s[1] = ivec3(1, 0, 0);
            s[2] = ivec3(1, 0, 1);
          }

          else {
            s[1] = ivec3(0, 0, 1);
            s[2] = ivec3(1, 0, 1);
          }
        }

        // dst.x < dst.y
        else {
          if (dst.y < dst.z) {
            s[1] = ivec3(0, 0, 1);
            s[2] = ivec3(0, 1, 1);
          }

          else if (dst.x < dst.z) {
            s[1] = ivec3(0, 1, 0);
            s[2] = ivec3(0, 1, 1);
          }

          else {
            s[1] = ivec3(0, 1, 0);
            s[2] = ivec3(1, 1, 0);
          }
        }

        // Offsets for conrners
        vec3 offset[] = vec3[](
          dst,
          dst - vec3(s[1]) + G,
          dst - vec3(s[2]) + 2.0 * G,
          dst - vec3(s[3]) + 3.0 * G
        );

        // Gradients
        vec3 g[4];
        for (int i = 0; i < 4; ++i) {
          g[i] = hash(internal, s[i]);
        }

        // Interpolate
        vec3 tmp;
        float t = 0.0;
        float n[] = float[](0.0, 0.0, 0.0, 0.0);

        for (int i = 0; i < 4; ++i) {
          tmp = pow(offset[i], vec3(2.0));
          t = 0.5 - tmp.x - tmp.y - tmp.z;

          if (t > 0.0) {
            t *= t;
            n[i] = t * t * dot(g[i], offset[i]);
          }
        }

        const float normalization = 37.837227241611314102871574478976;

        // ~[-1.0, 1.0]
        return (normalization * (n[0] + n[1] + n[2] + n[3]));
      }

      float noise(in vec2 p) {
        return noise(vec3(p, 0.0));
      }

      /**
       * Calculates derivative of the noise (on 2D slice)
       */
      vec2 dnoise2(in vec3 p) {
        // Coordinates
        vec2 coord = p.xy;

        // Delta
        float delta = 1.0 / 100000.0;
        float freq = 1.0;

        float o = noise(freq * coord);

        // Dn/Dx
        //float x1 = noise(freq * (coord - vec2(delta, 0.0)));
        float x1 = o;
        float x2 = noise(freq * (coord + vec2(delta, 0.0)));
        float dx = (x2 - x1) / delta / 2.0;

        // Dn/Dy
//        float y1 = noise(freq * (coord - vec2(0.0, delta)));
        float y1 = o;
        float y2 = noise(freq * (coord + vec2(0.0, delta)));
        float dy = (y2 - y1) / delta / 2.0;

        return vec2(dx, dy);
      }

      vec3 dnoise3(in vec3 p) {
        // Coordinates
        vec3 coord = p;

        // Delta
        float delta = 1.0 / 10000.0;

        // Dn/Dx
        float x1 = noise(coord - vec3(delta, 0.0, 0.0));
        float x2 = noise(coord + vec3(delta, 0.0, 0.0));
        float dx = (x2 - x1) / delta;

        // Dn/Dy
        float y1 = noise(coord - vec3(0.0, delta, 0.0));
        float y2 = noise(coord + vec3(0.0, delta, 0.0));
        float dy = (y2 - y1) / delta;

        // Dn/Dz
        float z1 = noise(coord - vec3(0.0, 0.0, delta));
        float z2 = noise(coord + vec3(0.0, 0.0, delta));
        float dz = (z2 - z1) / delta;

        return vec3(dx, dy, dz);
      }

      vec2 cnoise2(in vec3 p) {
        vec2 d = dnoise2(p);
        return vec2(d.y, -d.x);
      }

      vec3 cnoise3(in vec3 p) {
        vec3 d = dnoise3(p);
        return vec3(d.z - d.y, d.x - d.z, d.y - d.x);
      }

      void main() {
        // Get the current position in the position map
        //vec3 current = texture(previousFrame, interpolatedLocalPosition.xy / vec2(size)).xyz;

        // Add the curl to it
        //current += vec3(cnoise2(interpolatedLocalPosition + current), 0.0);

        //gl_FragColor = vec4(current, 1.0);
        gl_FragColor = vec4((cnoise2(interpolatedPosition / 400.0) + 1.0) / 2.0, 0.0, 1.0);
        //gl_FragColor = vec4(interpolatedLocalPosition / 400.0, 1.0);
      }
    </script>

  </head>
  <body onload="onLoad()">
    <div id="myCanvasContainer"></div>
    <canvas id="canvas"></canvas>
  </body>
</html>
